<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解决Ubuntu关机卡界面90s</title>
    <url>/2020/01/14/%E8%A7%A3%E5%86%B3Ubuntu%E5%85%B3%E6%9C%BA%E5%8D%A1%E7%95%8C%E9%9D%A290s/</url>
    <content><![CDATA[<h1 id="解决ubuntu关机卡界面90s"><a href="#解决ubuntu关机卡界面90s" class="headerlink" title="解决ubuntu关机卡界面90s"></a>解决ubuntu关机卡界面90s</h1><p>注意了，这个不是系统的问题，是配置的问题。网上有很多其他的方案，下载watchdog啊，或者一行命令什么的，其实只需要改一下配置文件就可以了。</p><p>sudo vim /etc/systemd/system.conf</p><p>可以使用vim也可以使用ubuntu自带的gedit，用vim的话需要先apt安装一下。</p><a id="more"></a>


<p># This file is part of systemd.<br>#<br># systemd is free software; you can redistribute it and/or modify it<br># under the terms of the GNU Lesser General Public License as published by<br># the Free Software Foundation; either version 2.1 of the License, or<br># (at your option) any later version.<br>#<br># Entries in this file show the compile time defaults.<br># You can change settings by editing this file.<br># Defaults can be restored by simply deleting this file.<br>#<br># See systemd-system.conf(5) for details.</p>
<p>[Manager]<br>#LogLevel=info<br>#LogTarget=journal-or-kmsg<br>#LogColor=yes<br>#LogLocation=no<br>#DumpCore=yes<br>#ShowStatus=yes<br>#CrashChangeVT=no<br>#CrashShell=no<br>#CrashReboot=no<br>#CtrlAltDelBurstAction=reboot-force<br>#CPUAffinity=1 2<br>#JoinControllers=cpu,cpuacct net_cls,net_prio<br>#RuntimeWatchdogSec=0<br>#ShutdownWatchdogSec=10min<br>#CapabilityBoundingSet=<br>#SystemCallArchitectures=<br>#TimerSlackNSec=<br>#DefaultTimerAccuracySec=1min<br>#DefaultStandardOutput=journal<br>#DefaultStandardError=inherit<br><strong>#DefaultTimeoutStartSec=90s</strong><br><strong>#DefaultTimeoutStopSec=90s</strong><br>#DefaultRestartSec=100ms<br>#DefaultStartLimitIntervalSec=10s<br>#DefaultStartLimitBurst=5<br>#DefaultEnvironment=<br>#DefaultCPUAccounting=no<br>#DefaultIOAccounting=no<br>#DefaultIPAccounting=no<br>#DefaultBlockIOAccounting=no<br>#DefaultMemoryAccounting=no<br>#DefaultTasksAccounting=yes<br>#DefaultTasksMax=<br>#DefaultLimitCPU=<br>#DefaultLimitFSIZE=<br>#DefaultLimitDATA=<br>#DefaultLimitSTACK=<br>#DefaultLimitCORE=<br>#DefaultLimitRSS=<br>#DefaultLimitNOFILE=<br>#DefaultLimitAS=<br>#DefaultLimitNPROC=<br>#DefaultLimitMEMLOCK=<br>#DefaultLimitLOCKS=<br>#DefaultLimitSIGPENDING=<br>#DefaultLimitMSGQUEUE=<br>#DefaultLimitNICE=<br>#DefaultLimitRTPRIO=<br>#DefaultLimitRTTIME=<br>#IPAddressAllow=<br>#IPAddressDeny=</p>
<p>配置文件大概就长这样，找到加粗的俩行，把#注释去掉并且修改时间为1，就可以解决了</p>
]]></content>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU寄存器总结</title>
    <url>/2020/01/01/CPU%E5%AF%84%E5%AD%98%E5%99%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>X86架构通用寄存器只有8个，其余为不可直接操作寄存器。在叙述寄存器单元之前，我们先将CPU内部分为三大块：</p><h1 id="控制单元（Control-Unit）"><a href="#控制单元（Control-Unit）" class="headerlink" title="控制单元（Control Unit）"></a>控制单元（Control Unit）</h1><p>程序计数器 PC（Program Counter）、指令寄存器 IR(Instruction Register)、指令译码器 ID(Instruction Decoder)和操作控制器 OC(Operation Controller)。</p><a id="more"></a>

<h1 id="运算逻辑单元（Arithmetic-Logic-Unit）"><a href="#运算逻辑单元（Arithmetic-Logic-Unit）" class="headerlink" title="运算逻辑单元（Arithmetic Logic Unit）"></a>运算逻辑单元（Arithmetic Logic Unit）</h1><p>算术运算与逻辑运算，进行加减乘除基础运算与位移运算。</p>
<h1 id="储存单元（Storage-Unit）"><a href="#储存单元（Storage-Unit）" class="headerlink" title="储存单元（Storage Unit）"></a>储存单元（Storage Unit）</h1><p>包含寄存器，片内缓存L1~L4，其中L1分为数据缓存与指令缓存，L4主要在Iris上以eDRAM的形式存在。<br><img src="https://i.loli.net/2020/01/01/dlNgGqe8pP4oCB7.png" alt="X64片内寄存器"></p>
<h2 id="状态寄存器"><a href="#状态寄存器" class="headerlink" title="状态寄存器"></a>状态寄存器</h2><table>
<thead>
<tr>
<th>字长</th>
<th>通用寄存器</th>
<th>指针寄存器</th>
<th>索引寄存器</th>
<th>区段寄存器</th>
<th>标志寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>16 Bits</td>
<td>AX BX CX DX</td>
<td>BP SP IP</td>
<td>SI DI</td>
<td>CS DS SS ES</td>
<td>FLAGS</td>
</tr>
<tr>
<td>32 Bits</td>
<td>EAX EBX ECX EDX</td>
<td>EBP ESP EIP</td>
<td>ESI EDI</td>
<td>CS DS SS ES FS GS</td>
<td>EFLAGS</td>
</tr>
<tr>
<td>64 Bits</td>
<td>RAX RBX RCX RDX R8~R15</td>
<td>RBP RSP RIP</td>
<td>RSI RDI</td>
<td>CS DS SS ES FS GS</td>
<td>RFLAGS</td>
</tr>
</tbody></table>
<ul>
<li>AX BX CX DX 可分为高八位与低八位，例AH（High），BL（Low），寄存器之间的长度必须相同才可进行运算。</li>
<li>BP —— Base Pointer（基址指针），SP —— Stack Pointer (堆栈指针)，标记Stack基准和移动的指针。</li>
<li>指针寄存器IP记录下一条指令的偏移地址。</li>
<li>指针寄存器SI DI指向数组内部。</li>
<li>区段寄存器CS DS SS ES 产生储存器的绝对地址。</li>
<li>标记寄存器FLAGS标志零位，奇偶，符号，进位等。</li>
<li>EAX EBX ECX EDX 低16位与AX BX CX DX相兼容。</li>
<li>R8~R15为X64新增通用寄存器。<br><img src="https://i.loli.net/2020/01/01/a8oTr61zkEIUFGX.png" alt="通用寄存器"><br><img src="https://i.loli.net/2020/01/01/XJr6tRqWGwQ5KlN.png" alt="指针寄存器"></li>
</ul>
<h2 id="指令集专用寄存器"><a href="#指令集专用寄存器" class="headerlink" title="指令集专用寄存器"></a>指令集专用寄存器</h2><p>（我的CPU为i7-6700HQ : X86,X86-64,MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2,VT-x, AVX, AVX2, FMA3, AES,TSX）</p>
<ul>
<li><p>MM —— MMX（Matrix Math eXtensions，矩阵数学扩展）指令集使用，SIMD(单指令多数据(Single Instruction Multiple Data))多媒体指令集，意在提高多媒体处理能力。</p>
</li>
<li><p>XMM —— SSE（Streaming SIMD Extensions，单一指令多数据流扩展）指令集使用，MMX继任，主要用于提高数学运算性能。</p>
</li>
<li><p>YMM ZMM —— AVX (Advanced Vector Extensions，高级向量扩展指令集)指令集使用，作为AVX继任，将XMM寄存器扩展到YMM乃至512 Bits的ZMM。</p>
</li>
<li><p>VT-x指令集主要用于硬件虚拟化操作，AES指令集主要用于提高系统加解密速度，FMA为AVX指令集子集，用来提高特定运算场景运算速度。</p>
<h2 id="系统专用寄存器："><a href="#系统专用寄存器：" class="headerlink" title="系统专用寄存器："></a>系统专用寄存器：</h2></li>
<li><p>CR —— Control Register（控制寄存器）</p>
</li>
<li><p>DR —— Debug Register（调试寄存器）</p>
</li>
<li><p>TR —— Test Register（测试寄存器）</p>
</li>
</ul>
<p><strong><em>改动此类寄存器需要Ring 0级别的权限，所以我称之为操作系统专用寄存器。</em></strong></p>
<p>二十一世纪二十年代第一天，莫有啥好说的。</p>
]]></content>
  </entry>
  <entry>
    <title>Windows蓝屏分析</title>
    <url>/2019/12/21/Windows%E8%93%9D%E5%B1%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2019/12/21/lh62Q7pJroKAG1I.png" alt="Windows10蓝屏"></p><blockquote>
<p>蓝屏死机（英语：Blue Screen of Death，缩写为：BSoD）指的是微软Windows 操作系统在无法从一个系统错误中恢复过来时所显示的屏幕图像。</p>
</blockquote><p>先抛出来解决方案：</p><ul>
<li>卸载最近一次的Windows更新，并尝试加载最近一次正常启动时的注册表</li>
<li>卸载最近安装的驱动程序或者尝试升级/降级该驱动</li>
<li>移除最近添加的硬件设备</li>
<li>将QQ更换为Windows Store的UWP版本并移除所有第三方杀毒软件</li>
<li>运行sfc /scannow以检查系统镜像</li>
<li>重装系统</li>
<li>重买电脑</li>
</ul><a id="more"></a>



<p><em>若无法正常启动，请尝试进入安全模式或者PE进行操作。</em></p>
<p><strong><em>所以定期备份是个很好的习惯！本文中需要额外下载的示例或者资料，均可与<a href="https://mega.nz/#F!gwcAWC5a!w1X2WHX07_uIs6IPDFLYbw" target="_blank" rel="noopener">此处</a>下载。</em></strong></p>
<hr>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>首先需要说明的是，Windows蓝屏是一种系统保护机制（可以把Windows蓝屏比喻成感冒/发烧），是Windows为保护硬件及数据的策略，当发生诸如内存非法访问，堆栈溢出等错误而Windows无法处理时，Windows将主动崩溃。虽然蓝屏的原因有很多，但其一定发生在内核层(Ring 0)。</p>
<blockquote>
<p>  crash type:<br>      0x01: High IRQL fault (Kernel-mode)<br>      0x02: Buffer overflow<br>      0x03: Code overwrite<br>      0x04: Stack trash<br>      0x05: High IRQL fault (User-mode)<br>      0x06: Stack overflow<br>      0x07: Hardcoded breakpoint<br>      0x08: Double Free  </p>
</blockquote>
<p>以上是<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/notmyfault" target="_blank" rel="noopener">NotMyFault</a>列举的常见Windows崩溃原因。</p>
<h1 id="崩溃分析"><a href="#崩溃分析" class="headerlink" title="崩溃分析"></a>崩溃分析</h1><p>当Windows崩溃时，显示器会切换至低分辨率下的VGA显示模式，显示蓝色背景并给出停止代码与建议，当Dump文件转存完毕后，系统将自动进行重启。 </p>
<h2 id="蓝屏代码"><a href="#蓝屏代码" class="headerlink" title="蓝屏代码"></a>蓝屏代码</h2><p>我们可以根据Windows蓝屏时候的错误代码进行初步判断，但无法将错误定位到具体驱动或者进程。蓝屏恢复方法可以参考<a href="https://support.microsoft.com/zh-cn/help/14238/windows-10-troubleshoot-blue-screen-errors" target="_blank" rel="noopener">微软官方指引</a>，具体错误代码可以查阅<a href="https://www.lifewire.com/blue-screen-error-codes-4065576" target="_blank" rel="noopener">此网站</a>或者查阅前文资料中的Code Lists。至于我为什么不贴中文译版，因为翻译实在太烂了。</p>
<h2 id="Dump分析"><a href="#Dump分析" class="headerlink" title="Dump分析"></a>Dump分析</h2><p>很不幸的是，很多时候蓝屏代码并不能帮助你准确定位问题，以便解决具体的进程或者驱动。这个时候我们需要分析Windows的内存崩溃转储文件来得出具体结论，这里的内核Dump文件即为发生崩溃时内存的部分/完整内容拷贝，具体步骤如下文所述。</p>
<h3 id="创建转储文件"><a href="#创建转储文件" class="headerlink" title="创建转储文件"></a>创建转储文件</h3><p>在Control Panel\System and Security\System的Advanced system settings选项，Advanced选项卡，Startup and Recovery选项下便可设置。<br><img src="https://i.loli.net/2019/12/21/5KjNAcOpTgzlxBQ.png" alt="Startup and Recovery"><br>拉开Write debugging information选项即可查看转储内存类型：None/Small/Kernel/Complete/Automatic/Active。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>None</td>
<td>不创建转储日志</td>
</tr>
<tr>
<td>Small</td>
<td>仅保留基本信息，引起崩溃的线程内核栈与关联内存栈</td>
</tr>
<tr>
<td>Kernel</td>
<td>保留当前运行时的进程列表，堆栈以及驱动程序列表</td>
</tr>
<tr>
<td>Complete</td>
<td>记录Windows崩溃时能够访问的所有内存</td>
</tr>
<tr>
<td>Automatic</td>
<td>类似Kernel,但在Paging file大小存在差异</td>
</tr>
<tr>
<td>Active</td>
<td>类似Complete，但初步筛选故障Pages</td>
</tr>
</tbody></table>
<h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><h4 id="WinDbg"><a href="#WinDbg" class="headerlink" title="WinDbg"></a>WinDbg</h4><p>目前微软发布WinDbg主要借助Windows SDK，安装可以参考<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools" target="_blank" rel="noopener">文档</a>,或者使用我提供的<a href="https://drive.google.com/open?id=172F-H7PuzsEIHrN8ToktxjtCfQXiMasR" target="_blank" rel="noopener">离线包</a>。<img src="https://i.loli.net/2019/12/21/JW6TRiEo1XndDQx.png" alt="WinDbg测试页面"></p>
<h4 id="WinDbg-Preview"><a href="#WinDbg-Preview" class="headerlink" title="WinDbg Preview"></a>WinDbg Preview</h4><p>预览版为UWP应用，可直接于Microsoft Store直接下载。<img src="https://i.loli.net/2019/12/21/DLEeG5znMm7FcUW.png" alt="Store详情页"><br><img src="https://i.loli.net/2019/12/21/ipKDLcve2XJwb9N.png" alt="WinDbg Preview测试页面"><br>Tips:如果你需要参考其它指南的话，建议安装前者，网络上大多资料均介绍此版本，不过二者差距较小，当然我很喜欢后者。</p>
<h3 id="Symbols配置"><a href="#Symbols配置" class="headerlink" title="Symbols配置"></a>Symbols配置</h3><blockquote>
<p>When applications, libraries, drivers, or operating systems are linked, the linker that creates the .exe and .dll files also creates a number of additional files known as symbol files.</p>
</blockquote>
<p>在崩溃分析中，我们可以使用Symbols来定位Windows原生应用或者内容发生崩溃时的具体进程，驱动，函数。配置Symbols有若干方法，以下推荐两种，请根据实际条件选择：</p>
<ul>
<li>配置环境变量在本地缓存并指向Symbols公共服务器，新建系统系统变量，名称设置为_NT_SYMBOL_PATH，变量值为SRV*c:\symbol*<a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="noopener">http://msdl.microsoft.com/download/symbols</a> ，其中SRV*与*http://… 之间的路径为Symbols文件在本地的缓存路径，例如我的缓存路径为c:\symbol。<br>该句的意思即告诉WinDbg，Symbols文件位于c:\symbol，当在该路径下无法寻找到目标Symbols时，主动从<a href="http://msdl.microsoft.com/download/symbols" target="_blank" rel="noopener">http://msdl.microsoft.com/download/symbols</a> 下载缓存。<br><img src="https://i.loli.net/2019/12/21/K26xPoJul9yQ1zG.png" alt="Symbols路径配置"><br>重启系统后生效，在这里分享一个技能点，在cmd中输入<code>set PATH=C:</code>后关闭cmd即可使环境变量在Windows不重启的情况下生效。</li>
<li>借助dbgcmd（注意不是cmd），输入<code>.symfix+ c:\symbol</code>即可将当前Workspace的Symbols指向c:\symbol，之后再使用<code>.sympath</code>即可输出当前Symbols的配置路径，最后<code>reload</code>便可开始根据当前系统版本同步Symbols，如果一切正常，你会在C:\symbol目录下看到下载的文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; .symfix c:\symbol  </span><br><span class="line">0: kd&gt; .sympath  </span><br><span class="line">Symbol search path is: srv*  </span><br><span class="line">Expanded Symbol search path is: cache*c:\symbol;SRV*https://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure>

<p>配置好的测试页面会出现类似下图的提示，<code>Symbol search path is: SRV\*c:\symbol\* http://msdl.microsoft.com/download/symbols。</code><img src="https://s2.ax1x.com/2019/12/21/Qx9msP.jpg" alt="PATH路径"><br>Tips:</p>
<ul>
<li>！<strong><em>目前msdl服务器似乎被墙了，请将代理置为全局。</em></strong></li>
<li>下载Symbols的过程中左下角会提示当前下载的任务名称，右侧会出现进度条，如果没有，请检查网络。</li>
<li>！！！<strong><em>网络问题很重要</em></strong></li>
<li>如果安装过程中遇到困难，请尝试将WinDbg的安装目录添加到环境变量中，以便寻找到SYMSRV.DLL和SYMSTORE.EXE。然而，我无法寻找到UWP版本的安装目录，请安装上文提到的第一个版本的WinDbg。<h3 id="Dump分析-1"><a href="#Dump分析-1" class="headerlink" title="Dump分析"></a>Dump分析</h3>把文件丢进WinDbg等待Symbols下载完成后便可开始分析，如果你运气够好，初步的分析下，你可能会看到“Probably caused by ***”的文本，基本上即为出现问题的具体驱动/进程了。</li>
</ul>
<p>如果没有分析结果，或者全部指向ntoskrnl类似的内核程序时，我们需要考虑进一步分析。在dbgcmd中输入<code>!analyze -v</code>便可开始进一步分析，我们可能会看到类似如下的Stack_text调用情况。<br><img src="https://i.loli.net/2019/12/21/mK8h31QSATxktjc.png" alt="Stack调用"><br>计算机中的Stack向低地址方向生长，于是从下至上分析，可以看到是nvlddmkm先后调用了dxgkrnl的DpiDispatchPower，DpiFdoDispatchPower，DpiFdoHandleDevicePower函数，在调用DpiFdoHandleDevicePower后即引发了watchdog.exe，随后NT内核的KeBugCheckEx启动，引发蓝屏。我们可以推测出出错的程序可能是dxgkrnl或者nvlddmkm，即DirectX程序，nVidia驱动程序。因此建议对DX进行修复，对N卡驱动进行升/降级。<br><img src="https://i.loli.net/2019/12/21/NXoWJ6dAZvRSHBc.png" alt="MODULE_NAME"><br>从文件末尾的MODULE_NAME可以看到端倪，基本判断问题为DirectX程序与nVidia驱动的不兼容。</p>
<p>我们随后又进行了验证，dbgcmd中输入<code>!process</code>即可开始验证。<br><img src="https://i.loli.net/2019/12/21/L1flQTV2ISywXR6.png" alt="验证"><br>在这里我们较为关注<code>Image: System</code>这句与<code>ReadMemory error: Cannot get nt!KeMaximumIncrement value.
fffff78000000000: Unable to get shared data</code>基本判断为栈溢出。</p>
<h3 id="驱动判断"><a href="#驱动判断" class="headerlink" title="驱动判断"></a>驱动判断</h3><p>你可以使用Google来搜索该驱动属于何种设备，并尝试更新/回退。当Google搜索不到一些冷门硬件时，我们需要使用lm(list module)，使用命令<code>lm kv m nvlddmkm</code>(k——kernel，内核；v——verbose，详细；m——match，匹配）来列出该模块的具体信息。<img src="https://s2.ax1x.com/2019/12/21/QvvMOU.jpg" alt="nvlddmkm具体信息">上图中，我们可以看到列出了该模块的时间戳，路径，名称，校验码等。同时，通过查阅主机的注册表我们也可以得出具体路径以及设备。</p>
<h1 id="作死之路"><a href="#作死之路" class="headerlink" title="作死之路"></a>作死之路</h1><p>如果你想要更多的Dump来分析，请左转Microsoft Community，我在我的附件里（前文可下载）附上了9份Dump文件，本次分析的文件结果也已导出为html格式，于附件中。<br>。<br>。<br>。<br>。<br>。<br>。<br>如果你想变得更强大，欢迎阅读书籍《深入解析Windows操作系统》，绝对是一本好书，就是有“点”厚？！<br><img src="https://s2.ax1x.com/2019/12/21/QxSjnf.jpg" alt="《深入解析Windows操作系统》第六版下册"></p>
]]></content>
  </entry>
  <entry>
    <title>如何输出Hello World！</title>
    <url>/2019/12/19/%E5%A6%82%E4%BD%95%E8%BE%93%E5%87%BAHello-World%EF%BC%81/</url>
    <content><![CDATA[<h1 id="One-issue！"><a href="#One-issue！" class="headerlink" title="One issue！"></a>One issue！</h1><p><strong><em>据说在学习一门语言的时候输出Hello World！会带来好运。</em></strong></p><p>哪怎么输出Hello World呢？难道就是像下面这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World!&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>是的，我们就是要输出上述源代码。</p>
<h1 id="输出源码"><a href="#输出源码" class="headerlink" title="输出源码"></a>输出源码</h1><p>如果我们直接运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Hello World!&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不出意外地报错，由于各种语言存在保留字以及需要使用无法输入的字符，因此需要对部分地方进行转义。<img src="https://s2.ax1x.com/2019/10/03/u0dVJS.jpg" alt="u0dVJS.jpg"><br>修改后的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;#include &lt;stdio.h&gt;\nint main()\n&#123;\nprintf(\&quot;Hello world\\n\&quot;);\nreturn 0;\n&#125;&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处，我们对换行符通过\n进行了转义,还对”以及\进行了转义。</p>
<h1 id="AWSL"><a href="#AWSL" class="headerlink" title="AWSL"></a>AWSL</h1><p><img src="https://s2.ax1x.com/2019/10/03/u0ySt1.jpg" alt="u0ySt1.jpg"><br>阿伟死了！这道题与上述问题相似，不过又有一个坑。<br><img src="https://s2.ax1x.com/2019/10/03/u0yxKS.jpg" alt="u0yxKS.jpg"><br>我最开始的源码是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main()\n&#123;\n\t//输出 Hello World !\n\tcout&lt;&lt;\&quot;Hello World !\&quot;&lt;&lt;endl;\n\n\treturn 0;\n&#125;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我使用了\n和\t来对上述源码进行转义，提交之后报格式错误。由于有了前几题的心酸历程，我去仔细看了下格式，发现缩进只有四个空格。而我使用Mingw-W64编译出来的代码中制表符占据了八个空格的位置，不同编译器以及编辑器的差异造成了上述问题。</p>
<p>修改后的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main()\n&#123;\n    //输出 Hello World !\n    cout&lt;&lt;\&quot;Hello World !\&quot;&lt;&lt;endl;\n\n    return 0;\n&#125;&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用Tab还是Space的问题上的讨论似乎成为了与Vim/Emacs哪个更好相似的问题。</p>
<h1 id="转义表"><a href="#转义表" class="headerlink" title="转义表"></a>转义表</h1><p>以下即为C语言常用转义字符表格：</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT)</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>&#39;</td>
<td>单引号</td>
<td>039</td>
</tr>
<tr>
<td>&quot;</td>
<td>双引号</td>
<td>034</td>
</tr>
<tr>
<td>\\</td>
<td>反斜杠</td>
<td>092</td>
</tr>
</tbody></table>
<p>当然C语言也提供一种数字转义方法，如下：</p>
<table>
<thead>
<tr>
<th>八进制转义</th>
<th>十六进制转义</th>
<th>名称/意义</th>
</tr>
</thead>
<tbody><tr>
<td>\7</td>
<td>\x07</td>
<td>响铃</td>
</tr>
<tr>
<td>\10</td>
<td>\x08</td>
<td>退格</td>
</tr>
<tr>
<td>\12</td>
<td>\x0A</td>
<td>换行</td>
</tr>
<tr>
<td>\14</td>
<td>\x0C</td>
<td>换页</td>
</tr>
<tr>
<td>\40</td>
<td>\x20</td>
<td>空格</td>
</tr>
<tr>
<td>\60</td>
<td>\x30</td>
<td>0</td>
</tr>
<tr>
<td>\101</td>
<td>\x41</td>
<td>A</td>
</tr>
<tr>
<td>\141</td>
<td>x61</td>
<td>a</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>win10下安装Python</title>
    <url>/2019/12/19/%E5%AE%89%E8%A3%85python/</url>
    <content><![CDATA[<hr>
<p><strong><em>我来砸场了！Windows在1903更新中实现了Python开箱即用的体验，你只需要在cmd中输入python3，系统便会引导你去Store下载Python依赖包。<img src="https://s2.ax1x.com/2019/12/19/QqGiQS.jpg" alt="QqGiQS.jpg"></em></strong></p>
<h3 id="1-自己的碎碎念"><a href="#1-自己的碎碎念" class="headerlink" title="1.自己的碎碎念"></a>1.自己的碎碎念</h3><h5 id="python现在作为很火的语言也越来越受大家欢迎，对有经验的程序猿还好，但对新手程序猿来说（尤其是选择恐惧症）来说，安装python恐怕是一件难事，今天就分享给大家我安装python的方法"><a href="#python现在作为很火的语言也越来越受大家欢迎，对有经验的程序猿还好，但对新手程序猿来说（尤其是选择恐惧症）来说，安装python恐怕是一件难事，今天就分享给大家我安装python的方法" class="headerlink" title="python现在作为很火的语言也越来越受大家欢迎，对有经验的程序猿还好，但对新手程序猿来说（尤其是选择恐惧症）来说，安装python恐怕是一件难事，今天就分享给大家我安装python的方法"></a>python现在作为很火的语言也越来越受大家欢迎，对有经验的程序猿还好，但对新手程序猿来说（尤其是选择恐惧症）来说，安装python恐怕是一件难事，今天就分享给大家我安装python的方法</h5><h3 id="2-环境需求"><a href="#2-环境需求" class="headerlink" title="2.环境需求"></a>2.环境需求</h3><p>win10</p>
<p>python版本：python3.7</p>
<a id="more"></a>
<h3 id="3-下载步骤"><a href="#3-下载步骤" class="headerlink" title="3.下载步骤"></a>3.下载步骤</h3><p>当然这里还有一个推荐方法就是直接利用微软自带的应用商店安装一键安装，也很方便。不过我个人还是比较喜欢这种手动下载的方法<br>1.首先要到python官网下载python，需要下载对应的版本（我觉得都9102年了应该很少有32位的电脑了吧）不过以防万一，大家还是去搜一下怎么去查自己系统多少位吧，我这里就不再赘述了</p>
<p><a href="https://www.python.org/downloads/windows/" target="_blank" rel="noopener">https://www.python.org/downloads/windows/</a> 这里是python的官方下载网址，估计不少初学者看见这个页面头都大了（就像我一样，不知道下载哪个）</p>
<p>首先你先选择你要安装的版本，</p>
<p><img src="http://47.98.136.155:8088/images/3b4273f83fa7f256.png" alt="image"></p>
<p>我们这里安装3.7.4版本，所以点击一下即可</p>
<p>进入页面后直接拉到最后有列表如下</p>
<p><img src="http://47.98.136.155:8088/images/833fdb8c7b135e78.png" alt="image"></p>
<p>(Windows x86-64 executable installer)我们点一下这个链接，就可以下载了</p>
<h3 id="4-安装步骤"><a href="#4-安装步骤" class="headerlink" title="4.安装步骤"></a>4.安装步骤</h3><p>下载完成后双击执行下载的exe程序，进入安装界面</p>
<p><img src="http://47.98.136.155:8088/images/8a1f28b5e2537a7c.png" alt="image"></p>
<p>请选择 Custo那一串（汉语意思为自定义安装，为啥不让他自动安装心里应该清楚）并且记得把该页面最下面俩个方框的对勾打上</p>
<p>然后直接点next进入这个页面</p>
<p><img src="http://47.98.136.155:8088/images/32538b853673ce41.png" alt="image"></p>
<p>这里你就可以自定义python的安装路径了，然后直接install即可</p>
<h3 id="5-验证安装"><a href="#5-验证安装" class="headerlink" title="5.验证安装"></a>5.验证安装</h3><p><img src="http://47.98.136.155:8088/images/3bfd2830789fe039.png" alt="image"> 安装完成后出现这个界面</p>
<p>然后再进入cmd 输入python -V</p>
<p>示例如下<br>如果显示python的版本则安装成功</p>
<p>则安装成功</p>
<p>开始愉快的使用python吧</p>
]]></content>
      <tags>
        <tag>代码</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux on Windows</title>
    <url>/2019/12/19/Linux-on-Windows/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>毋庸置疑的是，Windows是家用平台的巨头，Linux是服务器端的主流系统，而在实际生产中时常遇到需要使用二者的情况，而本篇文章正是讨论如何将二者安装于同一硬件基础上。其中包括既传统的双系统，虚拟机系统，又涉及Windows 10的新特性，WSL系统。</p><h1 id="双系统"><a href="#双系统" class="headerlink" title="双系统"></a>双系统</h1><p>基于硬件的双系统，此处概念的Linux完全独立于windows。优点是二者独立，互不干扰，且系统完整，不会出现诡异的问题，系统资源也能得到完整利用。</p><a id="more"></a>

<p>安装双系统只需要准备烧录好镜像的U盘（引导程序及镜像），并在BIOS里以U盘引导启动并按照指引完成安装即可。</p>
<p>当然，此种方案的缺点也十分明显，由于两个系统相互独立，因此要想进行切换，就必须进行硬件层次上的重启，不仅耗时而且资料会得到损失。</p>
<h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机的运行需要硬件的支持，因为某些CPU并不支持虚拟化。常见的Windows虚拟机包括但不仅限于virtualbox，VMware。。。此类虚拟机优势即是两者相对独立，并且可以随时进行切换，系统选择灵活，资源调控便捷。当然，优点多多，缺点也有，那就是资源占用问题，由于虚拟出了一个操作系统，因此，资源占用十分严重，而且常用虚拟软件的授权费挺贵哈。</p>
<p>安装流程也全称是GUI界面，不过需要注意资源的分配，虚拟机和主机的配置要恰到好处，避免虚拟机或主机发生卡顿，当然，既然是虚拟技术，就必然有性能损耗。</p>
<h1 id="巨硬WSL"><a href="#巨硬WSL" class="headerlink" title="巨硬WSL"></a>巨硬WSL</h1><p>巨硬这个可以说是非常硬了，WSL是“Windows Subsystem for Linux”的简称，从名称可以看出来WSL被归类为Windows的子系统，是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层，最早在Windows 10的1607中出现并延续下来。当然，这个子系统，非常干净，除去内核的文本Ubuntu 16.04LTS只有195MB大小。当然，这样的Linux是不自带编译器的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><img src="http://pccqnqw75.bkt.clouddn.com/18-8-7/9757038.jpg" alt></p>
<p>简的来说，便是LX会话器担任Windows与Linux交互的媒介，并通络内核模式与运行在用户模式下的Pico进行交互，Pico进程则负责模拟并运行相应的二进制文件，大部分情况下对Linux的操作会被映射为对Windows内核的调用。<br><a href="https://www.infoq.com/news/2016/04/linux-windows" target="_blank" rel="noopener">参考</a>。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1，Windows版本高于1607并在设置下的更新与安全中打开开发者人员模式。<img src="https://ws1.sinaimg.cn/large/0078xKluly1fu2fgs2sykj32yo1lse81.jpg" alt></p>
<p>2，接着在PowerShell下键入<br><code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code>以打开Windows子系统功能。</p>
<p>同样，也可以在控制面板下手动打开“适用于Windows的Linux子系统”。</p>
<p><img src="https://ws1.sinaimg.cn/large/0078xKluly1fu2ft9wyefj32yo1ltn4a.jpg" alt></p>
<p>3，重启之后在Microsoft Store下选择想要安装的Linux发行版，等待安装流程结束，设置新用户名及密码。</p>
<h2 id="后期配置"><a href="#后期配置" class="headerlink" title="后期配置"></a>后期配置</h2><p>系统安装之后，因为Ubuntu的默认root账户密码是每次开机随机生成的，可以使用<br><code>sudo passwd root</code><br>来修改root账户密码。</p>
<p>此外，由于众所周知的原因，Ubuntu的apt包管理服务器设在国外，因此需要修改为国内镜像源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 备份原文件</span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改源配置文件</span><br><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>修改内容为（当然可以选用其它软件源）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 默认注释了源码仓库，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>之后使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br></pre></td></tr></table></figure>

<p>更新包索引来生效。</p>
<p>当然，由于与Windows共用一套硬件，而Windows下的服务占用了22端口，因此需要更换Linux的SSH登陆端口。</p>
<p>修改配置文件之前使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /etc/ssh/sshd_config /etc/ssh/sshd_config_backup</span><br></pre></td></tr></table></figure>

<p>来备份原配置文件。此处通过修改/etc/shh/sshd_config来实现对SSH的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<p>进入编辑界面，接着修改port 为2333（或者其他不与Windows产生冲突的端口），将ListenAddress前的注释去掉以修改SSH监听地址。<img src="https://ws1.sinaimg.cn/large/0078xKluly1fu2ntq9bexj319c0hn76b.jpg" alt>接下来按照自己的需求修改对应值，例如可将UsePrivilegeSeparation值修改为no，PasswordAuthentication值修改为yes，PermitRootLogin修改为yes。具体依靠个人情况配置，这里贴一篇<a href="http://blog.51cto.com/xujpxm/1717862" target="_blank" rel="noopener">博文</a>。</p>
<p>安装配置之后，重启SSH服务。接着以IP为127.0.0.1或者主机localhost，端口号2333进行SSH连接。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh root@localhost -p 2333</span><br></pre></td></tr></table></figure>

<p>连接到本地SSH服务，倘若需要在主机以外访问SSH，则需配置防火墙。</p>
<p>安装基本组件后即可依据个人环境要求配置Linux，倘若报错，可能是因为这个精简的Linux缺少了依赖库，下载安装即可。</p>
<p>*</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#倘若遇到Cannot load host key则可以考虑重新生成公私匙。</span><br><span class="line">rm /etc/ssh/ssh*key</span><br><span class="line">dpkg-reconfigure openssh-serve</span><br></pre></td></tr></table></figure>

<p><img src="http://pccqnqw75.bkt.clouddn.com/18-8-8/19552218.jpg" alt></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>此种运行Linux的方式，占用系统资源少，调用方便，但由于是Windows子系统，因此存在一定的兼容问题，但是一般生产生活完全够用。</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>WSL提供了两种可被Linux访问的文件系统：VolFs和DriveFs。前者在各方面都非常类似于常规的Linux文件系统，包括权限支持、symbolic链接、大小写敏感，以及Windows文件系统中不允许使用的字符。后者提供了与Windows相互访问的方式，使得用户能够在Linux中看到所有Windows卷。</p>
<p>因此，Linux与Windows的资源是允许相互访问的，Linux下的/mnt挂载的有Windows的盘符，当然也有全部文件。</p>
<p><img src="https://ws1.sinaimg.cn/large/0078xKluly1fu2ooaw4lqj31uy0yu78q.jpg" alt><br>Windows下的Linux文件则存放在C:\Users[用户名]\AppData\Local\Packages[对应包名],例如我可以通过C:\Users\wrzto\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc来访问Linux资源。</p>
<p>当然，值得注意的是，但二者的资源处于相对竞争状态时，Windows优先获取资源。</p>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="http://mirrors.ustc.edu.cn/help/" target="_blank" rel="noopener">Linux修改软件源帮助</a></p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>从iCloud迁移照片到Google Photos</title>
    <url>/2019/12/19/%E4%BB%8EiCloud%E8%BF%81%E7%A7%BB%E7%85%A7%E7%89%87%E5%88%B0Google-Photos/</url>
    <content><![CDATA[<h1 id="缘由-amp-要求"><a href="#缘由-amp-要求" class="headerlink" title="缘由&amp;要求"></a>缘由&amp;要求</h1><p>Google大法好，Photos无限容量备份照片！</p><p>当然，需要一台位于境外的VPS，从iCloud上拉资源，再上传到Google Drive。</p><h1 id="从iCloud上下载"><a href="#从iCloud上下载" class="headerlink" title="从iCloud上下载"></a>从iCloud上下载</h1><p>由于Apple没有开放iCloud的API，于是关于iCloud下载的第三方程序少之又少。于是我找到了这个<a href="https://www.ctolib.com/ndbroadbent-icloud_photos_downloader.html" target="_blank" rel="noopener">icloudpd</a>。</p><a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#以Ubuntu/Debian系统为例</span><br><span class="line">#下载并安装pip，若为安装unzip，则需使用apt-get install unzip。</span><br><span class="line"> root@Raincorn:/icloud# wget https://bootstrap.pypa.io/get-pip.py --no-check-certificate</span><br><span class="line">--2019-01-30 20:58:55--  https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">Resolving bootstrap.pypa.io (bootstrap.pypa.io)... 151.101.0.175, 151.101.64.175, 151.101.128.175, ...</span><br><span class="line">Connecting to bootstrap.pypa.io (bootstrap.pypa.io)|151.101.0.175|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1700321 (1.6M) [text/x-python]</span><br><span class="line">Saving to: ‘get-pip.py’</span><br><span class="line"></span><br><span class="line">get-pip.py            100%[===========================&gt;]   1.62M  --.-KB/s   in 0.02s  </span><br><span class="line"></span><br><span class="line">2019-01-30 20:58:55 (79.4 MB/s) - ‘get-pip.py’ saved [1700321/1700321]</span><br><span class="line"></span><br><span class="line">root@Raincorn:/icloud# python get-pip.py</span><br><span class="line">DEPRECATION: Python 2.7 will reach the end of its life on January 1st, 2020. Please upgrade your Python as Python 2.7 won&apos;t be maintained after that date. A future version of pip will drop support for Python 2.7.</span><br><span class="line">Collecting pip</span><br><span class="line">  Downloading</span><br><span class="line">Successfully installed pip-19.0.1 setuptools-40.7.1 wheel-0.32.3</span><br><span class="line">#由于已经由pip收录，可以使用pip install icloudpd来安装icloudpd。</span><br></pre></td></tr></table></figure>

<p>使用<code>icloud photos</code>(注意，photos为你要保存照片的目录，可自定义为其他。)<br>接着会要求输入iCloud账号密码，验证完成后就会开始下载，我用了51分20秒把2324张照片下载了下来。但是为什么速度不理想，原因很大程度上是因为苹果的iCloud服务器由云上贵州接管，服务器在国内，晚上又是高峰时段。</p>
<h1 id="上传到Google-Drive"><a href="#上传到Google-Drive" class="headerlink" title="上传到Google Drive"></a>上传到Google Drive</h1><p>Google作为行业巨头，全力推行开源事业，有关Drive的有关程序网上比比皆是，我这里介绍我正在使用的一个名为<a href="https://rclone.org" target="_blank" rel="noopener">rclone</a>的管理程序。</p>
<h2 id="rclone的安装"><a href="#rclone的安装" class="headerlink" title="rclone的安装"></a>rclone的安装</h2><h3 id="下载rclone"><a href="#下载rclone" class="headerlink" title="下载rclone"></a>下载rclone</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按照官方Docs操作就好。</span><br><span class="line">#首先下载并解压rclone</span><br><span class="line">root@Raincorn:~# wget https://downloads.rclone.org/rclone-current-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">root@Raincorn:~# unzip rclone-current-linux-amd64.zip</span><br><span class="line"></span><br><span class="line">root@Raincorn:~# cd rclone-*linux-amd64</span><br></pre></td></tr></table></figure>

<h3 id="复制赋权"><a href="#复制赋权" class="headerlink" title="复制赋权"></a>复制赋权</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp rclone /usr/bin/</span><br><span class="line"></span><br><span class="line">chown root:root /usr/bin/rclone</span><br><span class="line"></span><br><span class="line">chmod 755 /usr/bin/rclone</span><br><span class="line">#至于为什么要有这一步，可以参考之前那篇关于[环境变量]（https://raincorn.top/2018/08/29/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/）的文章，间的来说，就是为了在用rclone时能够找到对应的程序。</span><br></pre></td></tr></table></figure>

<h3 id="安装帮助页面"><a href="#安装帮助页面" class="headerlink" title="安装帮助页面"></a>安装帮助页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/share/man/man1</span><br><span class="line"></span><br><span class="line">cp rclone.1 /usr/local/share/man/man1/</span><br><span class="line"></span><br><span class="line">mandb</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>键入rclone config即可进入配置页面。</p>
<p>这里是配置实例，基本上有些英语基础就没问题。也可以参考<a href="https://rclone.org/drive/" target="_blank" rel="noopener">https://rclone.org/drive/</a>    给出的实例，或者<a href="https://www.chenweiliang.com/cwl-694.html" target="_blank" rel="noopener">https://www.chenweiliang.com/cwl-694.html</a>    的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@Raincorn:/rclone# rclone config</span><br><span class="line">2019/01/30 21:25:58 NOTICE: Config file &quot;/root/.config/rclone/rclone.conf&quot; not found - using defaults</span><br><span class="line">No remotes found - make a new one</span><br><span class="line">n) New remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">n/s/q&gt; n（创建新的Drive类型）</span><br><span class="line">name&gt; Google（自定义配置的名称）</span><br><span class="line">Type of storage to configure.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">Choose a number from below, or type in your own value</span><br><span class="line"> 1 / A stackable unification remote, which can appear to merge the contents of several remotes</span><br><span class="line">   \ &quot;union&quot;</span><br><span class="line"> 2 / Alias for a existing remote</span><br><span class="line">   \ &quot;alias&quot;</span><br><span class="line"> 3 / Amazon Drive</span><br><span class="line">   \ &quot;amazon cloud drive&quot;</span><br><span class="line"> 4 / Amazon S3 Compliant Storage Providers (AWS, Ceph, Dreamhost, IBM COS, Minio)</span><br><span class="line">   \ &quot;s3&quot;</span><br><span class="line"> 5 / Backblaze B2</span><br><span class="line">   \ &quot;b2&quot;</span><br><span class="line"> 6 / Box</span><br><span class="line">   \ &quot;box&quot;</span><br><span class="line"> 7 / Cache a remote</span><br><span class="line">   \ &quot;cache&quot;</span><br><span class="line"> 8 / Dropbox</span><br><span class="line">   \ &quot;dropbox&quot;</span><br><span class="line"> 9 / Encrypt/Decrypt a remote</span><br><span class="line">   \ &quot;crypt&quot;</span><br><span class="line">10 / FTP Connection</span><br><span class="line">   \ &quot;ftp&quot;</span><br><span class="line">11 / Google Cloud Storage (this is not Google Drive)</span><br><span class="line">   \ &quot;google cloud storage&quot;</span><br><span class="line">12 / Google Drive</span><br><span class="line">   \ &quot;drive&quot;</span><br><span class="line">13 / Hubic</span><br><span class="line">   \ &quot;hubic&quot;</span><br><span class="line">14 / JottaCloud</span><br><span class="line">   \ &quot;jottacloud&quot;</span><br><span class="line"></span><br><span class="line">Storage&gt; 12（选择类型，会随着版本变动而有所变化。）</span><br><span class="line">** See help for drive backend at: https://rclone.org/drive/ **</span><br><span class="line"></span><br><span class="line">Google Application Client Id</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">client_id&gt; </span><br><span class="line">Google Application Client Secret</span><br><span class="line">Leave blank normally.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">client_secret&gt; </span><br><span class="line">Scope that rclone should use when requesting access from drive.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">Choose a number from below, or type in your own value</span><br><span class="line"> 1 / Full access all files, excluding Application Data Folder.</span><br><span class="line">   \ &quot;drive&quot;</span><br><span class="line"> 2 / Read-only access to file metadata and file contents.</span><br><span class="line">   \ &quot;drive.readonly&quot;</span><br><span class="line">   / Access to files created by rclone only.</span><br><span class="line"> 3 | These are visible in the drive website.</span><br><span class="line">   | File authorization is revoked when the user deauthorizes the app.</span><br><span class="line">   \ &quot;drive.file&quot;</span><br><span class="line">   / Allows read and write access to the Application Data folder.</span><br><span class="line"> 4 | This is not visible in the drive website.</span><br><span class="line">   \ &quot;drive.appfolder&quot;</span><br><span class="line">   / Allows read-only access to file metadata but</span><br><span class="line"> 5 | does not allow any access to read or download file content.</span><br><span class="line">   \ &quot;drive.metadata.readonly&quot;</span><br><span class="line">scope&gt; 1（即允许rclone获得你全部的Drive访问权限。）</span><br><span class="line">ID of the root folder</span><br><span class="line">Leave blank normally.</span><br><span class="line">Fill in to access &quot;Computers&quot; folders. (see docs).</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">root_folder_id&gt; </span><br><span class="line">Service Account Credentials JSON file path </span><br><span class="line">Leave blank normally.</span><br><span class="line">Needed only if you want use SA instead of interactive login.</span><br><span class="line">Enter a string value. Press Enter for the default (&quot;&quot;).</span><br><span class="line">service_account_file&gt; </span><br><span class="line">Edit advanced config? (y/n)</span><br><span class="line">y) Yes</span><br><span class="line">n) No</span><br><span class="line">y/n&gt; n（不进行高级配置。）</span><br><span class="line">Remote config</span><br><span class="line">Use auto config?</span><br><span class="line"> * Say Y if not sure</span><br><span class="line"> * Say N if you are working on a remote or headless machine or Y didn&apos;t work</span><br><span class="line">y) Yes</span><br><span class="line">n) No</span><br><span class="line">y/n&gt; n</span><br><span class="line">If your browser doesn&apos;t open automatically go to the following link: https://accounts.google.com/(你需要登陆的链接。)</span><br><span class="line">Enter verification code&gt; 4/4gBaYe2_（你在网页中获得erification code）</span><br><span class="line">Configure this as a team drive?</span><br><span class="line">y) Yes</span><br><span class="line">n) No</span><br><span class="line">y/n&gt; n</span><br><span class="line">--------------------</span><br><span class="line">[Google]</span><br><span class="line">type = drive</span><br><span class="line">scope = drive</span><br><span class="line">token = &#123;&quot;access_token&quot;:&quot;ya29.GluhBkLo5l7zLGZFmeHEbBSWFxJD8HaiAqpDLmD7BPPFUGcpXrgnnd8pWoahZJvgyv9Qk5yc7TxRLRmxKt31N8mmjP4bbvr2sSb_E8ZbpRNetFtglc2SrjMRFW6z&quot;,&quot;token_type&quot;:&quot;Bearer&quot;,&quot;refresh_token&quot;:&quot;1/jmLzUeXGBUqMVHV_k4x8F6UhPXkbMW-U-zJpnGnnv6I&quot;,&quot;expiry&quot;:&quot;2019-01-30T22:28:52.644486809+08:00&quot;&#125;</span><br><span class="line">--------------------</span><br><span class="line">y) Yes this is OK</span><br><span class="line">e) Edit this remote</span><br><span class="line">d) Delete this remote</span><br><span class="line">y/e/d&gt; y</span><br><span class="line">Current remotes:</span><br><span class="line"></span><br><span class="line">Name                 Type</span><br><span class="line">====                 ====</span><br><span class="line">Google               drive</span><br><span class="line"></span><br><span class="line">e) Edit existing remote</span><br><span class="line">n) New remote</span><br><span class="line">d) Delete remote</span><br><span class="line">r) Rename remote</span><br><span class="line">c) Copy remote</span><br><span class="line">s) Set configuration password</span><br><span class="line">q) Quit config</span><br><span class="line">e/n/d/r/c/s/q&gt; q</span><br></pre></td></tr></table></figure>

<h2 id="开始上传Google-Drive"><a href="#开始上传Google-Drive" class="headerlink" title="开始上传Google Drive"></a>开始上传Google Drive</h2><p>（本地文件夹以origin,Drive文件夹以backup为例）<br>在web端新建一个名为backup的文件夹，新建完成后使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@Raincorn:/rclone# rclone lsd Google:</span><br><span class="line">          -1 2019-01-30 21:32:54        -1 backup</span><br><span class="line">#这里的“Google”即为你所创建的配置名称，backup即为你刚刚新建的那个用来备份的文件夹。     </span><br><span class="line">root@Raincorn:/rclone# rclone copy /root/origin Google:backup</span><br><span class="line">#/root/origin为源文件夹，Google：backup为配置名称+远程文件夹。</span><br></pre></td></tr></table></figure>

<p>挂到Screen中，第二天即可迁移完成。</p>
]]></content>
  </entry>
  <entry>
    <title>Windows安装文件初探</title>
    <url>/2019/12/19/Windows%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<p>首先声明，我只是感兴趣于iso内的安装文件，并无他意，这篇文章也仅仅代表我个人的观点与立场。一个有意思的地方是，安装文件里的文本相当一部分编码采用的是扩展集UTF-16而非UTF-8或GBK。</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>我的系统是政府精简版1709,使用rufus烧录，大体上精简了一部分次要功能。<br><img src="https://s2.ax1x.com/2019/07/10/ZgubU1.png" alt="ZgubU1.png"></p><p>我的U盘位于/run/media/raincorn/WIN10_CMGE/，该目录下有5个文件夹以及4个文件。</p><a id="more"></a>


<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p><strong>注意，下文若未单独指明，文本文件内容编码则为UTF-8。</strong></p>
<h2 id="autorun-inf"><a href="#autorun-inf" class="headerlink" title="autorun.inf"></a>autorun.inf</h2><p>文件内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[AutoRun.Amd64]</span><br><span class="line">open=setup.exe</span><br><span class="line">icon=setup.exe,0</span><br><span class="line"></span><br><span class="line">[AutoRun]</span><br><span class="line">open=sources\SetupError.exe x64</span><br><span class="line">icon=sources\SetupError.exe,0</span><br></pre></td></tr></table></figure>

<p>inf文件，即为windows操作系统下用来描述设备或文件等信息的文件。此处的autorun.info，顾名思义，是针对X86 电脑的自动运行标识符。文件内容反馈出的含义为运行setup.exe，并可用于指定盘符图标。</p>
<h2 id="bootmgr"><a href="#bootmgr" class="headerlink" title="bootmgr"></a>bootmgr</h2><p>传统BIOS模式下的引导文件。</p>
<p>传统BIOS+MBR启动流程为： </p>
<ul>
<li>PC上电，主板芯片组加电自检（POST）。</li>
<li>自检通过则优先从设置的默认设备启动。</li>
<li>读取位于硬盘第一扇区的MBR记录，并搜寻活动分区。</li>
<li>在根目录下读取bootmgr（启动管理器），此时计算机控制权交由bootmgr。</li>
<li>bootmgr搜索boot目录下的BCD（启动配置数据），若存在多个启动选项则会交由用户选择，反之直接启动。</li>
<li>bootmgr继续读取并运行Windows\System32\winload.exe。</li>
<li>winload.exe则完成内核读取与其余启动过程。</li>
</ul>
<p>简洁版便是：BIOS-POST-MBR-Bootmgr-BCD-Winload.exe-内核</p>
<h2 id="bootmgr-efi"><a href="#bootmgr-efi" class="headerlink" title="bootmgr.efi"></a>bootmgr.efi</h2><p>UEFI启动的引导文件。</p>
<p>经典UEFI+GPT启动流程为：</p>
<ul>
<li>PC加电，UEFI 读取位于 ESP 分区 EFI/Microsoft/Boot/目录下的 bootmgfw.efi 。</li>
<li>运行bootmgr.efi并将计算机控制权交于 bootmgfw 。</li>
<li>bootmgfw搜索并读取EFI/Microsoft/Boot/BCD，若有多个启动选项则交由用户选择，反之启动默认系统。</li>
<li>默认启动 Windows之后，bootmgrfw 搜索并读取 Windows 分区 Windows\System32 目录下的 winload.efi 程序。</li>
<li>winload.efi完成后续内核加载与启动流程。</li>
</ul>
<p>二者区别：<img src="https://s2.ax1x.com/2019/07/12/ZWk9Ff.jpg" alt="ZgubU1.png"></p>
<h2 id="setup-exe"><a href="#setup-exe" class="headerlink" title="setup.exe"></a>setup.exe</h2><p>用于正常windows环境或者预安装环境下启动安装程序的应用文件。</p>
<h1 id="文件夹内容"><a href="#文件夹内容" class="headerlink" title="文件夹内容"></a>文件夹内容</h1><h2 id="boot"><a href="#boot" class="headerlink" title="boot"></a>boot</h2><p>BIOS启动流程所需的文件。</p>
<h2 id="EFI"><a href="#EFI" class="headerlink" title="EFI"></a>EFI</h2><p>UEFI启动流程所需的文件。</p>
<h2 id="sources"><a href="#sources" class="headerlink" title="sources"></a>sources</h2><p>Windowa安装文件所在位置，一般而言包含install.wim和预安装环境。</p>
<h2 id="support"><a href="#support" class="headerlink" title="support"></a>support</h2><p>包含帮助信息以及系统工具。</p>
]]></content>
  </entry>
  <entry>
    <title>Git初窥</title>
    <url>/2019/11/19/git%E5%88%9D%E7%AA%A5/</url>
    <content><![CDATA[<h1 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h1><p>因为学校留作业要交Github上，但又很厌烦在页面上点来点去的方法，所以写下命令行git提交文件的方法供大家使用，我个人认为如果会用的话是能提升工作效率的。</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>我假设你是在Windows系统上</p><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><a id="more"></a>



<p><img src="http://47.98.136.155:8088/images/git_bash2.png" alt="image"></p>
<p>安装完成了，请在命令行输入俩行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>其中把“Your name”更改为你的github名字</p>
<p>email更改为你的github注册的邮箱即可。</p>
<p>然后以我的github中的仓库为例吧</p>
<p>在你想要存放文件的地方打开git bash或者cmd命令行</p>
<p>然后输入</p>
<p>git clone +“你的仓库的地址”</p>
<p>我的就是 </p>
<p>git clone <a href="https://github.com/hhhhhpc/LabExercises_02" target="_blank" rel="noopener">https://github.com/hhhhhpc/LabExercises_02</a></p>
<p>然后等待下载你会发现有一个文件夹了，</p>
<p>然后使用cd命令进入这个文件夹</p>
<p><img src="http://47.98.136.155:8088/images/git_bash2.png" alt="image"></p>
<p>然后再文件夹里创建一个新的文件</p>
<p><img src="http://47.98.136.155:8088/images/git_bash3.png" alt="image"></p>
<p>当然，你可以在这个新的文件夹里放很多其他的东西。</p>
<p>然后在命令行里输入 git add . </p>
<p>这条命令是为了告诉git你添加了什么文件，用.这个通配符是让他把更改的文件都算上。</p>
<p>如果不报错的话请输入git commit -m “xxxx”</p>
<p>这是为了告诉git你这次提交更改了什么</p>
<p>就拿我这次来示例，我是创建了个test文件，就可以写</p>
<p>git commit -m “test”</p>
<p>如果这俩步里面报错了的话请不要慌张，一般你把报错信息复制去搜索一下都能解决问题。</p>
<p>然后这两步做完在命令行里输入</p>
<p>git push即可，这样你在本地文件夹里更改的操作就能更新在你的github上。</p>
<p>我个人是比较推荐这种方式的，毕竟点来点去的方法工作效率是有点低的。</p>
]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次博客迁移</title>
    <url>/2019/11/06/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="记录一下这次的博客迁移"><a href="#记录一下这次的博客迁移" class="headerlink" title="记录一下这次的博客迁移"></a>记录一下这次的博客迁移</h1><p>因为以前的懒和图方便，把图床和博客的服务器都放在了github上，白嫖别人的资源。</p><p>但事实证明了白嫖不是永久的</p><p><img src="http://47.98.136.155:8088/images/cry.jpg" alt="image"></p><p>在前几天就得到了惨痛的教训，因为图片放在github上，所以全部图片加载不出来，这也导致很多博客本来简单易懂，这一来，变得难的离谱，本来我还想等着等着他恢复凑合着用吧。</p><p>但当我一天想更新一篇文章的时候！！！！！！</p><a id="more"></a>




<p>我发现文章也没法更新了，而且github仓库里可以更新，但我的博客却不会更新，简直抓狂，无奈，只能选择把所有服务都部署在我自己的服务器上，这样才能不受人掣肘。</p>
<p>当然，因为博客也刚起步，整个迁移的工作量也不大，就是把所有图片的引用路径和以前在github部署的配置文件都改一下，但还是要引以为戒，尽量在自己可以掌控的范围内做事情。</p>
<p>冲冲冲！！！</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫初窥(三)</title>
    <url>/2019/10/21/python%E7%88%AC%E8%99%AB%E5%88%9D%E7%AA%A5-%E4%B8%89/</url>
    <content><![CDATA[<h1 id="python爬虫初窥（三）BeautifulSoup库"><a href="#python爬虫初窥（三）BeautifulSoup库" class="headerlink" title="python爬虫初窥（三）BeautifulSoup库"></a>python爬虫初窥（三）BeautifulSoup库</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>13上一篇演示了如何使用requests模块向网站发送http请求，获取到网页的HTML数据，而第一篇的时候就说过了，爬虫获取到信息后下面就是对信息的处理，而我比较喜欢使用处理数据的库是用BeautifulSoup这个库。</p><h3 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>同上篇一样 且自行安装BeautifulSoup库</p><a id="more"></a>

<p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/这里是这个库的中文网站。" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/这里是这个库的中文网站。</a></p>
<h3 id="3-开工"><a href="#3-开工" class="headerlink" title="3.开工"></a>3.开工</h3><h5 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1 原理"></a>3.1 原理</h5><p>Beautiful Soup将HTML文档看成一个复杂的树形结构，每个节点都是Python对象，而所有对象可以归纳为四个类型，Tag , NavigableString , BeautifulSoup , Comment</p>
<h5 id="3-2-Tag"><a href="#3-2-Tag" class="headerlink" title="3.2 Tag"></a>3.2 Tag</h5><p>我们知道HTML代码可以说所有内容都是存放在标签里的，而这个库的标签也是这个意思。</p>
<p>我们找个例子来了解一下吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line"></span><br><span class="line">html_doc = &quot;&quot;&quot;</span><br><span class="line">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;</span><br><span class="line">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were</span><br><span class="line">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and</span><br><span class="line">&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span><br><span class="line">and they lived at the bottom of a well.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">soup = BeautifulSoup(html_doc, &apos;lxml&apos;)  #声明BeautifulSoup对象</span><br><span class="line">find = soup.find(&apos;p&apos;)  #使用find方法查到第一个p标签</span><br><span class="line">print(&quot;find&apos;s return type is &quot;, type(find))  #输出返回值类型</span><br><span class="line">print(&quot;find&apos;s content is&quot;, find)  #输出find获取的值</span><br><span class="line">print(&quot;find&apos;s Tag Name is &quot;, find.name)  #输出标签的名字</span><br><span class="line">print(&quot;find&apos;s Attribute(class) is &quot;, find[&apos;class&apos;])  #输出标签的class属性值</span><br></pre></td></tr></table></figure>

<p><img src="http://47.98.136.155:8088/images/python_spider_2.png" alt="image"></p>
<p>可以看到，你查到的是第一个P标签。</p>
<p>而找到的标签里有 .name和.attribute类型，.attribute是返回那个class的类型</p>
<h5 id="3-3-NavigableString"><a href="#3-3-NavigableString" class="headerlink" title="3.3 NavigableString"></a>3.3 NavigableString</h5><p>这个就是标签中的文本内容但是不含标签，你可以试一下例子</p>
<p>再上面的例子中 最后一行加入print(‘NavigableString is：’, find.string)  就可以得到下面的输出</p>
<p><img src="http://47.98.136.155:8088/images/python_spider_3.png" alt="image"></p>
<h5 id="3-4-BeautifulSoup"><a href="#3-4-BeautifulSoup" class="headerlink" title="3.4 BeautifulSoup"></a>3.4 BeautifulSoup</h5><p>这个对象表示一个文档的全部内容，支持遍历文档树和搜索</p>
<h5 id="3-5-Comment"><a href="#3-5-Comment" class="headerlink" title="3.5 Comment"></a>3.5 Comment</h5><p>这个对象是HTML中的注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markup = &quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;</span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">comment = soup.b.string</span><br><span class="line">type(comment)</span><br><span class="line"># &lt;class &apos;bs4.element.Comment&apos;&gt;  //应该输出内容</span><br></pre></td></tr></table></figure>

<h5 id="3-6-BeautifulSoup的遍历方法"><a href="#3-6-BeautifulSoup的遍历方法" class="headerlink" title="3.6 BeautifulSoup的遍历方法"></a>3.6 BeautifulSoup的遍历方法</h5><p>一般常用的有子节点，父节点，及标签名的方式遍历</p>
<p>关于子节点和父节点的定义可参考这篇 <a href="https://www.w3school.com.cn/htmldom/dom_nodes.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/htmldom/dom_nodes.asp</a></p>
<h6 id="3-6-1-节点和标签名"><a href="#3-6-1-节点和标签名" class="headerlink" title="3.6.1 节点和标签名"></a>3.6.1 节点和标签名</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.head #查找head标签</span><br><span class="line">soup.p #查找第一个p标签</span><br><span class="line"></span><br><span class="line">#对标签的直接子节点进行循环</span><br><span class="line">for child in title_tag.children:</span><br><span class="line">    print(child)</span><br><span class="line"></span><br><span class="line">soup.parent #父节点</span><br><span class="line"></span><br><span class="line"># 所有父节点</span><br><span class="line">for parent in link.parents:</span><br><span class="line">    if parent is None:</span><br><span class="line">        print(parent)</span><br><span class="line">    else:</span><br><span class="line">        print(parent.name)</span><br><span class="line"></span><br><span class="line"># 兄弟节点</span><br><span class="line">sibling_soup.b.next_sibling #后面的兄弟节点</span><br><span class="line">sibling_soup.c.previous_sibling #前面的兄弟节点</span><br><span class="line"></span><br><span class="line">#所有兄弟节点</span><br><span class="line">for sibling in soup.a.next_siblings:</span><br><span class="line">    print(repr(sibling))</span><br><span class="line"></span><br><span class="line">for sibling in soup.find(id=&quot;link3&quot;).previous_siblings:</span><br><span class="line">    print(repr(sibling))</span><br></pre></td></tr></table></figure>

<h6 id="3-6-2-搜索文档树"><a href="#3-6-2-搜索文档树" class="headerlink" title="3.6.2 搜索文档树"></a>3.6.2 搜索文档树</h6><p>常用的方式是find()和find_all()，不常用的我就不多提了，想看的可以去官方文档查一下</p>
<p>可以通过tag的name，即名字为name的tag</p>
<p>attr参数，就是tag的属性，即class</p>
<p>string参数，搜索文档中字符串的内容</p>
<p>recursive 参数： 调用tag的 find_all() 方法时，Beautiful Soup会检索当前tag的所有子孙节点。如果只想搜索tag的直接子节点，可以使用参数 recursive=False 。可以看一下示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;title&quot;)</span><br><span class="line"># [&lt;title&gt;The Dormouse&apos;s story&lt;/title&gt;]</span><br><span class="line">#</span><br><span class="line">soup.find_all(&quot;p&quot;, &quot;title&quot;)</span><br><span class="line"># [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;]</span><br><span class="line"># </span><br><span class="line">soup.find_all(&quot;a&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,</span><br><span class="line">#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</span><br><span class="line">#</span><br><span class="line">soup.find_all(id=&quot;link2&quot;)</span><br><span class="line"># [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</span><br><span class="line">#</span><br><span class="line">import re</span><br><span class="line">soup.find(string=re.compile(&quot;sisters&quot;))</span><br><span class="line"># u&apos;Once upon a time there were three little sisters; and their names were\n&apos;</span><br></pre></td></tr></table></figure>

<p>现在最基本的python爬虫需要用的东西都已经介绍完了，下面来进行下实战吧</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>这次就爬个天气预报的信息好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url = &apos;http://www.weather.com.cn/weather/101230101.shtml&apos;</span><br><span class="line"></span><br><span class="line">header = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &apos;</span><br><span class="line">                      &apos;AppleWebKit/537.36 (KHTML, like Gecko) &apos;</span><br><span class="line">                      &apos;Chrome/69.0.3486.0 Safari/537.36&apos;&#125;  # 模拟一个报头，将爬虫变为浏览器</span><br><span class="line">response = requests.get(url=url, headers=header)</span><br><span class="line">response.encoding = &apos;utf-8&apos;    # 指定返回信息的编码格式</span><br><span class="line"></span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>然后输出内容应该是一大堆内容，这里就不贴图了。</p>
<p>然后现在我们找到我们需要爬下来的内容，首先打开开发者模式可以看到右边一坨花花绿绿的代码，不要慌张，我教你怎么正确寻找你要的东西。</p>
<p>以这个页面为例我们想要的肯定是这一部分内容</p>
<p><img src="http://47.98.136.155:8088/images/python_spider_5.png" alt="image"></p>
<p>你可以对着他们点击右键然后有个叫检查或者审查元素的按钮，这样你就可以看见右边的的代码会跳到一个地方，然后根据那个地方你可以找他的父节点或者其他的，可以看见他的HTML标签和class然后就可以用BS库进行提取了。</p>
<p><img src="http://47.98.136.155:8088/images/20191021173730.png" alt></p>
<p>就比如这个，这个单个的标签是 li class为 sky啥啥啥的的，而且可以看到他的父标签是ul class是</p>
<p>t clearfix</p>
<p><img src="http://47.98.136.155:8088/images/20191021173918.png" alt></p>
<p>然后我们验证一下，父标签果然就是这一列。</p>
<p>然后我们就开始用BS库进行解析吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">url = &apos;http://www.weather.com.cn/weather/101230101.shtml&apos;</span><br><span class="line"></span><br><span class="line">header = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &apos;</span><br><span class="line">                      &apos;AppleWebKit/537.36 (KHTML, like Gecko) &apos;</span><br><span class="line">                      &apos;Chrome/69.0.3486.0 Safari/537.36&apos;&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url=url, headers=header)</span><br><span class="line">response.encoding = &apos;utf-8&apos;</span><br><span class="line">soup = BeautifulSoup(response.text, &apos;lxml&apos;)</span><br><span class="line">weather = soup.find(&apos;ul&apos;, class_=&apos;t clearfix&apos;)  # 定位 HTML标签为UL 类型为t clearfix的内容</span><br><span class="line">print(weather.text)</span><br></pre></td></tr></table></figure>

<p>这个代码里面 weather就是我们想要提取出来的内容了。</p>
<p>当然你也可以通过正则表达式来获取更详细的信息。</p>
<p>然后你就可以对这些数据进行处理，比如文件的存贮，发送到其他地方，这都随你便了。</p>
<p>当然还有就是我们这里并没有应对反爬虫的机制，也没有涉及到发送post请求的爬虫，我就不赘述了，有兴趣的</p>
<p>关于python爬虫的教程就到这把，如果大家有兴趣的话可以去试点更多有意思的，比如爬图片然后存贮到其他地方，我这里就不再赘述了。</p>
]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫初窥（二）requests库</title>
    <url>/2019/10/16/python%E7%88%AC%E8%99%AB%E5%88%9D%E7%AA%A5%EF%BC%88%E4%BA%8C%EF%BC%89requests%E5%BA%93/</url>
    <content><![CDATA[<h1 id="python爬虫初窥（二）requests库"><a href="#python爬虫初窥（二）requests库" class="headerlink" title="python爬虫初窥（二）requests库"></a>python爬虫初窥（二）requests库</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><p>上一节说过了，爬虫是模拟浏览器向服务器发送请求，然后获取服务器的响应。然后再对数据进行处理，所以我们要利用requests库发送各种HTTP请求来获取网站上的数据。</p><h3 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2.运行环境"></a>2.运行环境</h3><p>系统版本</p><p>我使用的是win10，不太喜欢（其实还是没钱）Mac。。。。所以这个教程就以win为例了。</p><a id="more"></a>


<p>python版本</p>
<p>我的是3.6版本，关于如何下载python本博客里也有教程（滑稽）</p>
<h3 id="3-IDE"><a href="#3-IDE" class="headerlink" title="3.IDE"></a>3.IDE</h3><p>我使用的是pycharm，是JB公司的产品，简直好用的一批好吧。吹爆</p>
<h3 id="4-安装requests库"><a href="#4-安装requests库" class="headerlink" title="4.安装requests库"></a>4.安装requests库</h3><p>如何利用pycharm安装第三方库可以参考上篇教程贴的连接的例子。</p>
<p>而如果你想深入了解requests库的话可以参考这个文档<a href="http://cn.python-requests.org/zh_CN/latest/，这个文档还是很顶的。" target="_blank" rel="noopener">http://cn.python-requests.org/zh_CN/latest/，这个文档还是很顶的。</a></p>
<h3 id="5-开工"><a href="#5-开工" class="headerlink" title="5.开工"></a>5.开工</h3><p>废话这么多，想必大家也看烦了，现在开始编写代码吧。</p>
<p>由于本篇教程小白向，所以怎么使用pycharm写python代码也顺便教给你们吧</p>
<p><a href="https://jingyan.baidu.com/article/09ea3ede7826d5c0afde3942.html可以参考这篇教程" target="_blank" rel="noopener">https://jingyan.baidu.com/article/09ea3ede7826d5c0afde3942.html可以参考这篇教程</a></p>
<p>当然，我们这里要输入的代码不是hello world</p>
<p>而是下面的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="comment">#导入requests库</span></span><br><span class="line">r = requests.get(<span class="string">'https://haut-hardware-of-league.github.io/'</span>) <span class="comment">#像目标url地址发送get请求，返回一个response对象</span></span><br><span class="line">print(r.text) <span class="comment">#r.text是http response的网页HTML</span></span><br></pre></td></tr></table></figure>

<p>你是不是想问就这就这就这就这就这？</p>
<p>没错，就这就这就这就这就这</p>
<p>执行完之后底部便会出现输出结果，这就完成了python爬虫的第一步，获取网页的HTML内容。</p>
<p>当然你可以给get加其他参数或者使用post请求，当然，由于这里是小白向，就不多言了，而且我在上面贴的有中文的官方文档的连接，有兴趣深究的可以去看一下，下面我就再简单介绍一个requests库好了。</p>
<h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p>无参数的</p>
<p><code>r = requests.get(&quot;https://unsplash.com&quot;)</code></p>
<p>这也是我们刚刚用到的，其实就是向网站发送一个get请求，返回值存到了r里，r的type是response</p>
<p>当然get请求也可以传参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">r = requests.get(&quot;http://httpbin.org/get&quot;, params=payload)</span><br></pre></td></tr></table></figure>

<p>上面代码向服务器发送的请求就包含了俩个参数，key1和key2，以及俩个参数的值，</p>
<p>实际上构成了这个网址<a href="http://httpbin.org/get?key1=value1&amp;key2=value2" target="_blank" rel="noopener">http://httpbin.org/get?key1=value1&amp;key2=value2</a></p>
<h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><p>无参数的post请求和get请求一样只不过把get改为post即可</p>
<p>有参数的post请求其实和get也一样，也是把get改为post就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">r = requests.post(&quot;http://httpbin.org/post&quot;, data=payload)</span><br></pre></td></tr></table></figure>

<p>post请求是用来提交数据的，即填写一堆输入框比如账号密码啥的，然后提交。</p>
<p>其他请求平常用的也不多我就不赘述了。</p>
]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫初窥(一)</title>
    <url>/2019/10/15/python%E7%88%AC%E8%99%AB%E5%88%9D%E7%AA%A5-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="python爬虫初窥（一）"><a href="#python爬虫初窥（一）" class="headerlink" title="python爬虫初窥（一）"></a>python爬虫初窥（一）</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>互联网是由一个个站点和网络设备组成的大网，我们通过浏览器访问站点，站点把HTML,CSS,JS代码返回给浏览器，代码经由浏览器解析，将丰富多彩的页面呈现在我们眼前。而本教程是利用python进行爬虫的一个入入入入入入入入门级教程，小白向。</p><h3 id="1-什么是爬虫"><a href="#1-什么是爬虫" class="headerlink" title="1.什么是爬虫"></a>1.什么是爬虫</h3><p>如果我们把互联网比作一个蜘蛛网，数据便存放于蜘蛛网的各个节点，而爬虫就是一只小蜘蛛，</p><a id="more"></a>

<p>沿着网抓取自己的猎物（数据）</p>
<p>从技术层面来说，爬虫就是程序通过模拟浏览器的行为：向网站发起请求，获取网站的资源，</p>
<p>当然获取资源后还需要对数据进行提取和过滤这样才能继续使用。</p>
<h3 id="2-爬虫的基本流程"><a href="#2-爬虫的基本流程" class="headerlink" title="2.爬虫的基本流程"></a>2.爬虫的基本流程</h3><p>程序发送请求———&gt;获取响应内容————&gt;解析内容————&gt;保存数据</p>
<p>而这个流程里所需的知识一般有：</p>
<p>HTML，因为你要解析内容就要知道从内容中获取你想要的数据，所以这就需要你对HTML有所了解，这样你才知道你怎么去找你想要提取的内容。</p>
<p>Python，因为这篇教程是用python语言写的爬虫，所以对python的了解是必须的，如果你以前对python不了解，建议去<a href="https://learnku.com/docs/tutorial/3.7.0这个网站先了解一下python的基本语法。" target="_blank" rel="noopener">https://learnku.com/docs/tutorial/3.7.0这个网站先了解一下python的基本语法。</a></p>
<p>TCP/IP，HTTP协议，这些能让你了解爬虫的逻辑而不至于一头雾水去学习爬虫，</p>
<p>还有就是细分的话解析内容的时候需要，re（正则表达式），第三方解析库beautifulsoup，json模块等。保存数据的话可能牵扯到数据库或者文件读写等内容。</p>
<h3 id="3-http协议-请求与相应"><a href="#3-http协议-请求与相应" class="headerlink" title="3.http协议 请求与相应"></a>3.http协议 请求与相应</h3><p><img src="http://47.98.136.155:8088/images/python_spider_1.png" alt="image"></p>
<p>Request 用户将自己的请求通过浏览器(client)发送给服务器(server)，请求可能带自己的个人信息</p>
<p>Response:服务器接受请求，分析用户发来的请求信息，然后返回数据(返回数据可能包括图片，htmm，css，js的代码)</p>
<p>而Request分为GET/POST请求，GET一般为提交请求获取一个页面，而POST会提交数据给服务器然后获取新的页面</p>
<h3 id="4-运行环境"><a href="#4-运行环境" class="headerlink" title="4.运行环境"></a>4.运行环境</h3><p>我使用的是WIN10，python是3.7，IDE是PyCharm，Pycharm有社区版，而且如果学校能注册学校邮箱的话也是可以白嫖四年专业版的（咱们学校好像是可以的）。</p>
<h3 id="5-第三方库的安装"><a href="#5-第三方库的安装" class="headerlink" title="5.第三方库的安装"></a>5.第三方库的安装</h3><p>第三方库的安装的话，我个人建议如果不太熟悉不同版本python或者虚拟环境python和pip的关系的话，可以使用pycharm添加第三方库，也很方便。</p>
<p><a href="https://blog.csdn.net/qiannianguji01/article/details/50397046这是pycharm添加第三方库的教程。" target="_blank" rel="noopener">https://blog.csdn.net/qiannianguji01/article/details/50397046这是pycharm添加第三方库的教程。</a></p>
<p>因为pip方便是方便，但如果不太了解python第三方库添加日后可能会感到迷惑。</p>
<p>这次的教程就这样，下一篇开始代码的讲解</p>
]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>关于开发板</title>
    <url>/2019/09/30/%E5%85%B3%E4%BA%8E%E5%BC%80%E5%8F%91%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="为什么要学开发板"><a href="#为什么要学开发板" class="headerlink" title="为什么要学开发板"></a>为什么要学开发板</h1><p>众所周知，近些年，物联网是很火的一个名词，而它的兴盛源于对信息获取的便捷性。</p>
<p>而开发板是物联网中最重要的一环，可以说开发板配合传感器负责了物联网中的俩项，获取信息和传输信息。</p>
<p>而且物联网的入门没有想象中的那么难，而且物联网可以看做和互联网是一样的，只不过是连接了传感器并将信息发到一个地方并进行处理。</p>
<p>当然，我只告诉大家怎么学物联网中开发板即底层的部分，因为其他部分基本是软件工程或计科专业才会去做的数据处理和可视化等处理。</p>
<p>好了，不废话了，步入正题。</p>
<a id="more"></a>
<h2 id="我推荐的开发板类型"><a href="#我推荐的开发板类型" class="headerlink" title="我推荐的开发板类型"></a>我推荐的开发板类型</h2><p>如果是刚入门学习开发板的话，我比较推荐学习Arduino体系，因为Arduino体系是类C的代码编写，而且相较于其他体系是资源最多的体系，而Arduino体系里比较好用的开发板有Arduino UNO，Arduino Mega，这俩个是比较经典的开发板而且实用性比51强得多。如果想购买的话可以去淘宝或者京东购买。</p>
<h2 id="Arduino入门教程"><a href="#Arduino入门教程" class="headerlink" title="Arduino入门教程"></a>Arduino入门教程</h2><p>刚才也说过了，Arduino体系是资源最多的体系，这么多人珠玉在前，我就不献丑了，这里给大家推荐一个比较好的地方</p>
<p><a href="http://mc.dfrobot.com.cn/thread-280817-1-1.html" target="_blank" rel="noopener">http://mc.dfrobot.com.cn/thread-280817-1-1.html</a></p>
<p>而且这里面有购买配套套件的地方，就是有点小贵，建议大家量力而行，俩仨个人一起买一套也行。</p>
<p>这里面教程也是比较详细的，你知道LED灯 长脚是正极短脚负极，而在开发板上需要自己在代码里定义正极接口，负极就是GND接口。</p>
<p>基本就能正确的完成里面的所有示例。</p>
<h2 id="ESP32板子（进阶部分）"><a href="#ESP32板子（进阶部分）" class="headerlink" title="ESP32板子（进阶部分）"></a>ESP32板子（进阶部分）</h2><p>如果你把上面的所有示例都完成了的话，且继续有兴趣钻研开发板，</p>
<p>那这部分就是为你精心准备的，如果上面的示例做完了，且感觉自己对开发板没啥兴趣，也可以看看这部分图一乐，不想看的话也不会有很大的影响。</p>
<p>我开始也说了，开发板负责了获取信息和传输信息，如果细心的话你们也发现了，Arduino的教程里面只涉及到了获取信息，或者控制点小东西，完全没和网络进行交互。</p>
<p>其实也不能说没有和网络进行交流，只是教程里没有体现罢了，我想你可能记得有的教程里用到了串口监视器，而串口监视器其实也是一种开发板和电脑进行通信，你也可以用电脑获取到信息然后再和外界就行信息的交流只是有点麻烦而已，有兴趣的话可以自己了解一下，或者可以私聊问我，这里就不再赘述了。</p>
<p>好了，步入这个专题的正题，ESP32板子。</p>
<p>当然ESP32有很多体系方法去编写代码，这里只提供Arduino体系的教程。</p>
<p>当然，ESP32作为开发板界的新贵，拥护他的人也不少。我在这里给大家贴出我认为很好的教程链接（真的不是我懒，真的是珠玉在前，我写很可能会误导大家）</p>
<p>Arduino IDE 配置ESP32的环境</p>
<p><a href="https://blog.csdn.net/Naisu_kun/article/details/84958561" target="_blank" rel="noopener">https://blog.csdn.net/Naisu_kun/article/details/84958561</a></p>
<p>而这个教程里面，看到编写上传程序即可，批量烧录固件到模块中不用看。</p>
<p>而ESP32 连接网络（应该是手机开热点，校园网应该不行）</p>
<p><a href="https://blog.csdn.net/solar_Lan/article/details/80049747" target="_blank" rel="noopener">https://blog.csdn.net/solar_Lan/article/details/80049747</a></p>
<p>ESP32基础的应该就这些了进阶的项目建议看这里</p>
<p><a href="https://randomnerdtutorials.com/?s=ESP32+Arduino" target="_blank" rel="noopener">https://randomnerdtutorials.com/?s=ESP32+Arduino</a> </p>
<p>虽然是英文文档但确实不错，用翻译凑合看吧</p>
]]></content>
      <tags>
        <tag>代码</tag>
      </tags>
  </entry>
  <entry>
    <title>选择正确的浏览器</title>
    <url>/2019/09/25/%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<p>对于浏览器的选择，这里肯定首推chrome</p>
<p>当然无脑尬吹不可取，</p>
<p>先说说它的优点：chrome速度快和简洁是最大的优点，而且书签比起其他的浏览器方便很多，基于google账号可以实现多端同步（但是吧可能需要一点其他手段才能申请google账号）而且不会弹窗广告</p>
<p>还有就是如果学习前端的话，F12（开发者模式）也挺方便的</p>
<a id="more"></a>
<p>但缺点同样不少：最大的问题就是可能占用内存较大，然后就是不支持网银，还有和Flash几乎水火不容，我都不知道为什么，有时候，我明明设置好了flash一直允许，下次打开网页又要我重新设置</p>
<p>当然chrome的一些快键键就不再多说了打开设置按钮都可以看到，什么shift+左键看新窗口，ctrl+左键开界面，估计大伙也都知道。</p>
<p>关于如何给一个网页权限</p>
<p><img src="http://47.98.136.155:8088/images/chrome_img_1.png" alt="image"></p>
<p>是在隐私设置里的的网站设置里，在这里面就可以设置给一个网站什么权限了，一般推荐大家使用先询问，不要设置禁止，当年我用chrome抢课就吃了没弹窗的亏，我还在痛骂学校的网站，后来才知道原来是我自己憨批了。。。</p>
<p>然后还有就是设置下载内容最好改一下地址，我记得默认好像是C。。</p>
<p>这里搜索引擎的话，我主推bing</p>
<p>如果想玩一下别人的界面的话可以先选择你想修改的东西，右击点检查，然后界面就会变成这样，</p>
<p><img src="http://47.98.136.155:8088/images/chrome_img_2.png" alt="image"></p>
<p>然后对着双击对着里面的内容修改就行了，当然这种东西只会在你的电脑上有效，因为这个网站的本质前端文件还是没有改变的，只是在你这显示出来的被你改变了而已。</p>
<p>还有就是一些搜索引擎的应用，想了解的话可以去知乎上或着百度搜一下，挺多教程的，这里我就不赘述了。</p>
<p>当然既然谈到chrome了就离不开插件了，当然很多优秀的插件需要在google应用商店下载，也有的在国内站点有资源可以下载使用。<br>我这里给大家推荐几个我比较喜欢用的插件吧<br>OneTab，可以一键把你的所有标签页变成一个列表，节省内存，你用的时候可以从中选择打开一个或打开多个，我挺喜欢的。<br>AdGuard广告拦截器挺方便的，可以去除很多广告（滑稽）简直爽的一批<br>还有就是万能的Tampermonkey也就是俗称油候，用他运行脚本简直爽的不要不要的，而且网络上有很多写好的脚本，简直万能。<br>划词翻译的话我觉得可以要也可以不要，chrome自己也带翻译，不过好像只能全文。<br>好了，就到这吧，不啰嗦了。</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>解决美帝良心想装上Ubuntu没网的问题</title>
    <url>/2019/09/15/%E8%A7%A3%E5%86%B3%E7%BE%8E%E5%B8%9D%E8%89%AF%E5%BF%83%E6%83%B3%E8%A3%85%E4%B8%8AUbuntu%E6%B2%A1%E7%BD%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>1.因为要写代码的时候需要Linux的环境，所以屁颠屁颠的掏出来了自己的优盘下了个Ubuntu18.04的镜像，然后做了个双系统（这一步具体怎么做网上教程很多，我也就不多说了）</p>
<p>2.然后开机的时候居然发现没有WiFi，没有WiFi，没有WiFi！！！</p>
<p>然后百度查了好多都说是驱动问题，结果我手机数据线插上电脑浪费了3个G装了无数遍驱动也没解决这个问题，最后看到了一个可能是</p>
<p>无线网卡没有权限的原因，然后就敲了两行命令，改了个配置文件，就可以愉快的连接上Wifi了，所以这里记录下来，供各位使用。</p>
<a id="more"></a>
<p>3.</p>
<p>首先你先确认你的驱动确实装了（具体怎么看，可以网上搜索），</p>
<p>第二步，打开终端，敲入 rfkill list all 会出现如下信息</p>
<p>0:ideapad_wlan: Wireless LAN<br>Soft blocked: no<br>Hard blocked:yes<br>1:ideapad_bluetooth: Bluetooth<br>Soft blocked: no<br>Hard blocked: yes<br>2:phy0: Wireless LAN<br>Soft blocked: no<br>Hard blocked:no<br>3:hci0: Bluetooth<br>Soft blocked: yes<br>Hard blocked: no</p>
<p>我们可以看到 ideapad_wlan的hard blocked默认为yes，所以导致wifi无法开启。</p>
<p>办法一（暂时）：</p>
<p>（1）sudo modprobe -r ideapad_laptop</p>
<p>输入完这个命令大概应该就可以连接WiFi了，但是呢还有一个问题就是，没有彻底解决问题，每次开机都要重新执行一次命令，所以我们需要改一下配置文件，以达到我们的目的。</p>
<p>方法二（推荐）：<br>通过列入黑名单的方式来实现自动移出ideapad_laptop设备。<br>1）创建/etc/modprobe.d/ideapad.conf文件：<br>sudo touch /etc/modprobe.d/ideapad.conf<br>2）编辑ideapad.conf文件：<br>sudo gedit ideapad.conf<br>3) 在ideapad.conf文件中添加：<br>blacklist ideapad_laptop<br>4) 关闭并保存ideapad.conf文件，移除ideapad_laptop设备：<br>sudo modprobe -r ideapad_laptop<br>5) 注销重启Ubuntu系统，可以看到无线设备能够被打开，并能搜索到WiFi信号。</p>
]]></content>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确下载一个软件</title>
    <url>/2019/09/10/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="如何正确下载一个软件"><a href="#如何正确下载一个软件" class="headerlink" title="如何正确下载一个软件"></a>如何正确下载一个软件</h1><p>众所周知，一般的比较好用的软件都是国外的（实话实说，国内软件做的确实拉跨）   ，所以很多时候下载成为了难住大家的第一关，鉴于确实很对人对英语有比较深的恐惧感，所以这篇博客，以受众较广的Adobe全家桶为例教大家如何下载软件。</p>
<h2 id="第一步：选择正确的搜索引擎"><a href="#第一步：选择正确的搜索引擎" class="headerlink" title="第一步：选择正确的搜索引擎"></a>第一步：选择正确的搜索引擎</h2><p>目前我想大家用的搜索引擎还是百度居多，但这里我要实名diss百度，使用百度很多时候前面好多篇都是广告，还有很多（balabalablabla。。。此处省略一万字）总而言之，现在的百度，往往是广告排在了广告的前面，所以我推荐大家使用bing的搜索引擎，虽然也会有广告，但排版方式比百度强了很多倍（别问我为啥不用goole，因为默认你们不会翻墙）</p>
<h2 id="第二步：-选择正确的搜索方式"><a href="#第二步：-选择正确的搜索方式" class="headerlink" title="第二步： 选择正确的搜索方式"></a>第二步： 选择正确的搜索方式</h2><p><img src="http://47.98.136.155:8088/images/ad97f5caf7dc399a.png" alt="image"></p>
<p>选择这种搜索方式，你知道哪个是官网吗？？？而且如果官网是英文，你会不会点进去就退出然后选择那种第三方软件园然后下载？</p>
<p>反正我当年是这么选的。</p>
<a id="more"></a>

<p>但如果你们选择搜索的时候多打上官网俩个字，也许结果就会不同</p>
<p><img src="http://47.98.136.155:8088/images/b0fa1c10391b5521.png" alt="image"></p>
<p>就像这样一样前俩个一般都是官网。</p>
<h2 id="第三步-选择要下载的版本"><a href="#第三步-选择要下载的版本" class="headerlink" title="第三步:选择要下载的版本"></a>第三步:选择要下载的版本</h2><p>ps:鉴于adobe官网是中文所以换成了下载pycharm</p>
<p><img src="http://47.98.136.155:8088/images/5a5996e679480e9b.png" alt="image"></p>
<p>进入官网之后，往往都会有一个大大大大大大的download键</p>
<p>点一下即可进入下载页面</p>
<p><img src="http://47.98.136.155:8088/images/de1908dea4283b09.png" alt="image"></p>
<p>一般点过download的页面就会进入选择下载哪个的页面，一般会让你选择下载具体哪种版本，选择你的操作系统，一般都选择windows，具体哪个版本应该也都有说明，可以翻译一波看看啥意思决定下载哪个，然后下载后安装就行了。</p>
<p>关于安装，无非是自定义安装到哪个盘里，需要加载哪些插件。</p>
<p>这里就不在赘述了。</p>
<p>所以，希望看完这篇教程的你，不要再问怎么下载XXX软件了，官网，download ，ok!!!!!!真·有手就行</p>
]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>ACM</title>
    <url>/2019/09/09/ACM/</url>
    <content><![CDATA[<h2 id="因为本社团ACM实力属实拉跨，所以只能找嘉豪学姐帮忙，所以链接指向的是嘉豪学姐的博客"><a href="#因为本社团ACM实力属实拉跨，所以只能找嘉豪学姐帮忙，所以链接指向的是嘉豪学姐的博客" class="headerlink" title="因为本社团ACM实力属实拉跨，所以只能找嘉豪学姐帮忙，所以链接指向的是嘉豪学姐的博客"></a>因为本社团ACM实力属实拉跨，所以只能找嘉豪学姐帮忙，所以链接指向的是嘉豪学姐的博客</h2><p><a href="https://blog.csdn.net/weixin_43870697" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43870697</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
